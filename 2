// GUI stuff
const zoomChange = (p)=>{
	document.getElementById("zoom").value			= p;
	document.getElementById("zoomOut").innerHTML	= p;
	document.getElementById("min").innerHTML		= -p;
	document.getElementById("max").innerHTML		= p;
	zoom											= p;
}
const xOffChange = (p)=>{
	document.getElementById("xOff").value			= p;
	document.getElementById("xOffOut").innerHTML	= p;
	xOff											= p;
}
const getMin = ()=> parseFloat(document.getElementById("min").innerHTML);
const getMax = ()=> parseFloat(document.getElementById("max").innerHTML);
const getZoom = ()=> parseFloat(document.getElementById("zoom").value);
const getxOff = ()=> parseFloat(document.getElementById("xOff").value);

// THREE.JS stuff
var camera, controls, scene, renderer;
var vertices		= [];
var graph			= {};
var zoom			= getZoom();
var xOff			= getxOff();

const init = ()=> {
	// camera stuff
		camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
		camera.position.z = 50;
		scene = new THREE.Scene();
	// graph stuff
	// renderer stuff
		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );
		//
		window.addEventListener( 'resize', onWindowResize, false );
	// controls
		controls = new THREE.OrbitControls( camera, renderer.domElement );
}
const onWindowResize = ()=> {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );
}
const animate = ()=> {
	requestAnimationFrame( animate );
	controls.update();
	renderer.render( scene, camera );
}
const newGraph = (f,clr) => {
	// universal attributes
		var geometry = new THREE.BufferGeometry();
		var material = new THREE.PointsMaterial( {
			size:				1,
			sizeAttenuation:	true,
			alphaTest:			0.5,
			transparent:		true,
			color:				clr
		} );
		var vetices = [];
		var code = math.compile(f);
		var res = math.complex();
	// objective attributes
		for (var i=getMin(); i<=getMax(); i+=(getMax()-getMin())/200) {
			res = math.complex(code.eval({
				"x":i-xOff
			}));
			vertices.push(
				i,			/* x */
				res.re,		/* y */
				res.im,		/* z */
			)
		}
		geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
	// adding to scene
		return new THREE.Points( geometry,material );
}
const newFunc = (n="f",f="x^2",clr="#"+parseInt(Math.random()*0xFFFFFF).toString(16))=>{
	let tr = document.createElement("TR");
	let name = document.createElement("TD");
	let func = document.createElement("TD");
	let expr = document.createElement("input");
	let colr = document.createElement("input");
	name.innerHTML = n;
	expr.type = "text";
	expr.value=f;
	colr.type = "color";
	colr.value = clr;

	func.appendChild(expr);
	func.appendChild(colr);
	tr.appendChild(name);
	tr.appendChild(func);

	document.getElementById("funcs").appendChild(tr);
}

const render = ()=> {
	let ch = document.getElementById("funcs").children;
	for (var i=0; i<ch.length; i++) {

	}
}

init();
animate();


//	graph["lal"] = newGraph("e^(i*x/10)*10", 0xffffff);
//	scene.add( graph["lal"] );
